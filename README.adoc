:source-highlighter: coderay
:source-language: clojure
:toc:
:toc-placement: preamble
:sectlinks:
:sectanchors:
:sectnums:

image:https://img.shields.io/clojars/v/com.fulcrologic/fulcro-rad-kvstore.svg[link=https://clojars.org/com.fulcrologic/fulcro-rad-kvstore]

A Fulcro RAD plugin that provides an interface for building database adaptors to support databases that generally store
things as documents with keys.

== Trying it Out

This Fulcro RAD plugin with adaptors is in development and is not yet ready for production.

This project currently consists of two implementations of the Key Value adaptor - in memory via a Clojure atom and Redis.

A RAD Key Value Database plugin uses the adaptor. In turn this plugin is used by a recent copy of the
https://github.com/fulcrologic/fulcro-rad-demo[RAD Demo].

 RAD Demo -> Key Value plugin -> Key Value adaptor -> Redis | Firebase | MongoDB ...

Take a look inside `/src/demo-project/config/defaults.edn` just to check that the `:main` Key Value database is
`:clojure-atom`. We don't want to have to install Redis just yet.

In a terminal type `make cljs`. Shadow CLJS should lead you through the browser/CLJS part of the installation. For the
server side setup a REPL choosing 'Run with Deps' with the alias `dev`. Optionally set 'JVM Args'
to `-Dguardrails.enabled=true`. Bring the REPL up. `(user/refresh)` will reload the namespaces and `(user/restart)` will
get the Demo's dependency graph of Mount components up and running.

Back to the client. Bring up a browser tab at http://localhost:9630/ and start a watch on the `:main` build. When
compilation is complete refresh the browser at http://localhost:3000/. The Demo Application should now be working.

== Conventions

The following namespace aliases are used in the content of this document:

[source, clojure]
-----
(ns x
  (:require
     [com.fulcrologic.rad.database-adapters.key-value.adaptor :as kv-adaptor]
     [com.fulcrologic.rad.database-adapters.key-value.entity-read :as kv-entity-read]
     [com.fulcrologic.rad.database-adapters.key-value.write :as kv-write]
     [com.fulcrologic.rad.database-adapters.key-value.database :as kv-database]
     [com.fulcrologic.rad.database-adapters.key-value.pathom :as kv-pathom]
     [com.example.components.config :as config]
     [com.example.components.delete-middleware :as delete]
     [com.example.components.save-middleware :as save]
     [com.example.components.parser :as parser]
     [com.fulcrologic.rad.pathom :as pathom]
     [immutant.web :as web]
     ))
-----

The namespaces for the plugin and the adaptor are both under `com.fulcrologic.rad.database-adapters.key-value`.
The RAD Demo is at `com.example`.

== Functions

The protocol is `::kv-adaptor/KeyStore` and has methods such as `::kv-adaptor/read1` and `::kv-adaptor/write1`. `read1` accepts
an ident and returns a map (entity) where all the joins are idents. `write1` accepts those two (ident, map) as arguments. There
are also plural versions of these methods: `read*` and `write*`. To avoid the inconvenience of dealing with idents
you may prefer to use the functions `::kv-entity-read/read-tree` and `::kv-write/write-tree`.
`read-tree` will fully expand the ident you give it into tree form by making calls to `read1` and `read*`.
All the joins will have become maps or vectors of maps - so no idents.
`write-tree` will do the opposite, deconstructing a tree structure and calling `write*`.

Please see the Demo for uses of these functions, and read the doc strings for further details.

== RAD Integration

The Key Value RAD plugin comes with delete and save middleware so you don't have to write your own
Pathom mutations. It is capable of generating the 'fill in the entity attributes' Pathom resolvers.
It injects values into the Pathom `env` that are then picked up by these resolvers.
There is a function to start the plugin that picks up values set in the RAD configuration.

.Entry points from RAD Demo into RAD plugin
|===
|Description |Demo Mount component |Function call

|Generation of Pathom resolvers
|`com.example.components.auto-resolvers/automatic-resolvers`
|`::kv-pathom/generate-resolvers`

|Save Middleware
|`::save/middleware`
|`::kv-pathom/wrap-save`

|Delete Middleware
|`::delete/middleware`
|`::kv-pathom/wrap-delete`

|What the Pathom `env` requires
|`::parser/parser`
|`::kv-pathom/pathom-plugin`

|Create connection
|`::config/config`,`com.example.components.seeded-connection/kv-connections`
|`::kv-database/start`
|===

One last area of integration not included on this table is where your hand written resolvers need to query the
database. Here the queries will be passed the Pathom `env` - so they can grab the connection. With the connection
in hand a query can call functions from the namespaces `::kv-adaptor` and `::kv-entity-read`.

== Comparison with Datomic Database plugin

Compared to the Datomic plugin some things have been left undone.

Even although the Pathom `env` of this plugin has `::key-value/connections` and `::key-value/databases` only
one connection/database is ever used. (With this type of database there is no difference between a connection and a
database). So with current functionality we could get away with just having `::key-value/database`.
The Datomic plugin requires this setup to support sharding, which has been left undone for the Key Value plugin.
Note that even if we switched to using `::key-value/database` in the `env`, we could still keep `::key-value/databases`
in the config file.

There is no automatic schema generation. Unlike Datomic, Key Value databases do not have schemas to generate.

This plugin currently eschews looking to RAD attributes to ascertain the primary key of entities, instead making
the assumption that your schema strictly adheres to each entity instance having one '/id' attribute. Thus if you do not need
automatic Pathom resolver generation then this plugin can be used outside of RAD. You just need to take over the
creation of the adaptor (rather than calling `::kv-database/start`):

  (redis-adaptor/->RedisKeyStore {:pool {} :spec {:uri "redis://127.0.0.1:6379/"}} options)

The last significant thing this plugin lacks is the useful function
`::datomic/empty-db-connection` that gives a data-less database - good for making tests that build up
just the data they need, not touching existing databases. The closest we have is
`::kv-database/destructive-reset` which requires an existing database and destroys data.

== Queries

Key Value databases are all about storing information at a location and retrieving it back again. There is no
concept of tables or retrieving data from them according to some predicate logic. Despite this, and merely to
get the Demo working, a method called `::kv-adaptor/read-table` is part of this adaptor. You will need to
set `:key-value/table-kludge?` to true in order to get it to work. This is an option to the creation of
any `::kv-adaptor/KeyStore`, set when using RAD via the .edn configuration files.

We just show a couple of example queries from the Demo. All queries are called from custom Pathom resolvers.

 (let [read-tree (kv-entity-read/read-tree-hof db env)]
      (->> (kv-adaptor/read-table db env :account/id)
           (map read-tree)
           (filter :account/active?)))

 (-> (kv-adaptor/read1 db env [:invoice/id invoice-id])
     :invoice/customer
     second)

== Redis Installation

These instructions worked well for me (on a Linux machine):
https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04

== Updating Demo project

Apart from `com.example.components` and `config`, overwrite all with new files. So `com.example`: `client.cljs`,
`model.cljc` and `ui.cljc`, then `com.example.model` and `com.example.ui`. The mount components should not change but
you might want to check the `.edn` config files. `time-zone` is Datomic-specific so remove it by commenting out
`timezone/attributes` from `com.example.model` and on whatever UIs TZ appears - in `fo/attributes` in `AccountForm`
for example.

== Copyright and License

Copyright (c) 2017-2019, Fulcrologic, LLC
The MIT License (MIT)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit
persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
